/**
 * @fileoverview added by tsickle
 * Generated from: lib/gridsterConfig.constant.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { CompactType, DirTypes, DisplayGrid, GridType } from './gridsterConfig.interface';
/** @type {?} */
export var GridsterConfigService = {
    gridType: GridType.Fit,
    // 'fit' will fit the items in the container without scroll;
    // 'scrollVertical' will fit on width and height of the items will be the same as the width
    // 'scrollHorizontal' will fit on height and width of the items will be the same as the height
    // 'fixed' will set the rows and columns dimensions based on fixedColWidth and fixedRowHeight options
    // 'verticalFixed' will set the rows to fixedRowHeight and columns width will fit the space available
    // 'horizontalFixed' will set the columns to fixedColWidth and rows height will fit the space available
    fixedColWidth: 250,
    // fixed col width for gridType: 'fixed'
    fixedRowHeight: 250,
    // fixed row height for gridType: 'fixed'
    keepFixedHeightInMobile: false,
    // keep the height from fixed gridType in mobile layout
    keepFixedWidthInMobile: false,
    // keep the width from fixed gridType in mobile layout
    setGridSize: false,
    // sets grid size depending on content
    compactType: CompactType.None,
    // compact items: 'none' | 'compactUp' | 'compactLeft' | 'compactUp&Left' | 'compactLeft&Up'
    mobileBreakpoint: 640,
    // if the screen is not wider that this, remove the grid layout and stack the items
    minCols: 1,
    // minimum amount of columns in the grid
    maxCols: 100,
    // maximum amount of columns in the grid
    minRows: 1,
    // minimum amount of rows in the grid
    maxRows: 100,
    // maximum amount of rows in the grid
    defaultItemCols: 1,
    // default width of an item in columns
    defaultItemRows: 1,
    // default height of an item in rows
    maxItemCols: 50,
    // max item number of cols
    maxItemRows: 50,
    // max item number of rows
    minItemCols: 1,
    // min item number of columns
    minItemRows: 1,
    // min item number of rows
    minItemArea: 1,
    // min item area: cols * rows
    maxItemArea: 2500,
    // max item area: cols * rows
    margin: 10,
    // margin between grid items
    outerMargin: true,
    // if margins will apply to the sides of the container
    outerMarginTop: null,
    // override outer margin for grid
    outerMarginRight: null,
    // override outer margin for grid
    outerMarginBottom: null,
    // override outer margin for grid
    outerMarginLeft: null,
    // override outer margin for grid
    useTransformPositioning: true,
    // toggle between transform or top/left positioning of items
    scrollSensitivity: 10,
    // margin of the dashboard where to start scrolling
    scrollSpeed: 20,
    // how much to scroll each mouse move when in the scrollSensitivity zone
    initCallback: undefined,
    // callback to call after grid has initialized. Arguments: gridsterComponent
    destroyCallback: undefined,
    // callback to call after grid has destroyed. Arguments: gridsterComponent
    gridSizeChangedCallback: undefined,
    // callback to call after grid has changed size. Arguments: gridsterComponent
    itemChangeCallback: undefined,
    // callback to call for each item when is changes x, y, rows, cols.
    // Arguments: gridsterItem, gridsterItemComponent
    itemResizeCallback: undefined,
    // callback to call for each item when width/height changes.
    // Arguments: gridsterItem, gridsterItemComponent
    itemInitCallback: undefined,
    // callback to call for each item when is initialized.
    // Arguments: gridsterItem, gridsterItemComponent
    itemRemovedCallback: undefined,
    // callback to call for each item when is initialized.
    // Arguments: gridsterItem, gridsterItemComponent
    itemValidateCallback: undefined,
    // callback to call to validate item position/size. Return true if valid.
    // Arguments: gridsterItem
    enableEmptyCellClick: false,
    // enable empty cell click events
    enableEmptyCellContextMenu: false,
    // enable empty cell context menu (right click) events
    enableEmptyCellDrop: false,
    // enable empty cell drop events
    enableEmptyCellDrag: false,
    // enable empty cell drag events
    enableOccupiedCellDrop: false,
    // enable occupied cell drop events
    emptyCellClickCallback: undefined,
    // empty cell click callback
    emptyCellContextMenuCallback: undefined,
    // empty cell context menu (right click) callback
    emptyCellDropCallback: undefined,
    // empty cell drag drop callback. HTML5 Drag & Drop
    emptyCellDragCallback: undefined,
    // empty cell drag and create item like excel cell selection
    emptyCellDragMaxCols: 50,
    // limit empty cell drag max cols
    emptyCellDragMaxRows: 50,
    // limit empty cell drag max rows
    scale: 1,
    // scale param to zoom in/zoom out
    // Arguments: event, gridsterItem{x, y, rows: defaultItemRows, cols: defaultItemCols}
    ignoreMarginInRow: false,
    // ignore the gap between rows for items which span multiple rows (see #162, #224)
    draggable: {
        delayStart: 0,
        // milliseconds to delay the start of drag, useful for touch interaction
        enabled: false,
        // enable/disable draggable items
        ignoreContentClass: 'gridster-item-content',
        // default content class to ignore the drag event from
        ignoreContent: false,
        // if true drag will start only from elements from `dragHandleClass`
        dragHandleClass: 'drag-handler',
        // drag event only from this class. If `ignoreContent` is true.
        stop: undefined,
        // callback when dragging an item stops.  Accepts Promise return to cancel/approve drag.
        start: undefined,
        // callback when dragging an item starts.
        // Arguments: item, gridsterItem, event
        dropOverItems: false,
        // enable drop items on top other item
        dropOverItemsCallback: undefined // callback on drop over another item
        // Arguments: source, target, gridComponent
    },
    resizable: {
        delayStart: 0,
        // milliseconds to delay the start of resize, useful for touch interaction
        enabled: false,
        // enable/disable resizable items
        handles: {
            s: true,
            e: true,
            n: true,
            w: true,
            se: true,
            ne: true,
            sw: true,
            nw: true
        },
        // resizable edges of an item
        stop: undefined,
        // callback when resizing an item stops. Accepts Promise return to cancel/approve resize.
        start: undefined // callback when resizing an item starts.
        // Arguments: item, gridsterItem, event
    },
    swap: true,
    // allow items to switch position if drop on top of another
    swapWhileDragging: false,
    // allow items to switch position while dragging
    pushItems: false,
    // push items when resizing and dragging
    disablePushOnDrag: false,
    // disable push on drag
    disablePushOnResize: false,
    // disable push on resize
    pushDirections: { north: true, east: true, south: true, west: true },
    // control the directions items are pushed
    pushResizeItems: false,
    // on resize of item will shrink adjacent items
    displayGrid: DisplayGrid.OnDragAndResize,
    // display background grid of rows and columns
    disableWindowResize: false,
    // disable the window on resize listener. This will stop grid to recalculate on window resize.
    disableWarnings: false,
    // disable console log warnings about misplacement of grid items
    scrollToNewItems: false,
    // scroll to new items placed in a scrollable view
    disableScrollHorizontal: false,
    // disable horizontal scrolling
    disableScrollVertical: false,
    // disable vertical scrolling
    disableAutoPositionOnConflict: false,
    // disable auto-position of items on conflict state,
    dirType: DirTypes.LTR,
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JpZHN0ZXJDb25maWcuY29uc3RhbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9hbmd1bGFyLWdyaWRzdGVyMi8iLCJzb3VyY2VzIjpbImxpYi9ncmlkc3RlckNvbmZpZy5jb25zdGFudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBQyxXQUFXLEVBQUUsUUFBUSxFQUFFLFdBQVcsRUFBa0IsUUFBUSxFQUFDLE1BQU0sNEJBQTRCLENBQUM7O0FBRXhHLE1BQU0sS0FBTyxxQkFBcUIsR0FBbUI7SUFDbkQsUUFBUSxFQUFFLFFBQVEsQ0FBQyxHQUFHOzs7Ozs7O0lBTXRCLGFBQWEsRUFBRSxHQUFHOztJQUNsQixjQUFjLEVBQUUsR0FBRzs7SUFDbkIsdUJBQXVCLEVBQUUsS0FBSzs7SUFDOUIsc0JBQXNCLEVBQUUsS0FBSzs7SUFDN0IsV0FBVyxFQUFFLEtBQUs7O0lBQ2xCLFdBQVcsRUFBRSxXQUFXLENBQUMsSUFBSTs7SUFDN0IsZ0JBQWdCLEVBQUUsR0FBRzs7SUFDckIsT0FBTyxFQUFFLENBQUM7O0lBQ1YsT0FBTyxFQUFFLEdBQUc7O0lBQ1osT0FBTyxFQUFFLENBQUM7O0lBQ1YsT0FBTyxFQUFFLEdBQUc7O0lBQ1osZUFBZSxFQUFFLENBQUM7O0lBQ2xCLGVBQWUsRUFBRSxDQUFDOztJQUNsQixXQUFXLEVBQUUsRUFBRTs7SUFDZixXQUFXLEVBQUUsRUFBRTs7SUFDZixXQUFXLEVBQUUsQ0FBQzs7SUFDZCxXQUFXLEVBQUUsQ0FBQzs7SUFDZCxXQUFXLEVBQUUsQ0FBQzs7SUFDZCxXQUFXLEVBQUUsSUFBSTs7SUFDakIsTUFBTSxFQUFFLEVBQUU7O0lBQ1YsV0FBVyxFQUFFLElBQUk7O0lBQ2pCLGNBQWMsRUFBRSxJQUFJOztJQUNwQixnQkFBZ0IsRUFBRSxJQUFJOztJQUN0QixpQkFBaUIsRUFBRSxJQUFJOztJQUN2QixlQUFlLEVBQUUsSUFBSTs7SUFDckIsdUJBQXVCLEVBQUUsSUFBSTs7SUFDN0IsaUJBQWlCLEVBQUUsRUFBRTs7SUFDckIsV0FBVyxFQUFFLEVBQUU7O0lBQ2YsWUFBWSxFQUFFLFNBQVM7O0lBQ3ZCLGVBQWUsRUFBRSxTQUFTOztJQUMxQix1QkFBdUIsRUFBRSxTQUFTOztJQUNsQyxrQkFBa0IsRUFBRSxTQUFTOzs7SUFFN0Isa0JBQWtCLEVBQUUsU0FBUzs7O0lBRTdCLGdCQUFnQixFQUFFLFNBQVM7OztJQUUzQixtQkFBbUIsRUFBRSxTQUFTOzs7SUFFOUIsb0JBQW9CLEVBQUUsU0FBUzs7O0lBRS9CLG9CQUFvQixFQUFFLEtBQUs7O0lBQzNCLDBCQUEwQixFQUFFLEtBQUs7O0lBQ2pDLG1CQUFtQixFQUFFLEtBQUs7O0lBQzFCLG1CQUFtQixFQUFFLEtBQUs7O0lBQzFCLHNCQUFzQixFQUFFLEtBQUs7O0lBQzdCLHNCQUFzQixFQUFFLFNBQVM7O0lBQ2pDLDRCQUE0QixFQUFFLFNBQVM7O0lBQ3ZDLHFCQUFxQixFQUFFLFNBQVM7O0lBQ2hDLHFCQUFxQixFQUFFLFNBQVM7O0lBQ2hDLG9CQUFvQixFQUFFLEVBQUU7O0lBQ3hCLG9CQUFvQixFQUFFLEVBQUU7O0lBQ3hCLEtBQUssRUFBRSxDQUFDOzs7SUFFUixpQkFBaUIsRUFBRSxLQUFLOztJQUN4QixTQUFTLEVBQUU7UUFDVCxVQUFVLEVBQUUsQ0FBQzs7UUFDYixPQUFPLEVBQUUsS0FBSzs7UUFDZCxrQkFBa0IsRUFBRSx1QkFBdUI7O1FBQzNDLGFBQWEsRUFBRSxLQUFLOztRQUNwQixlQUFlLEVBQUUsY0FBYzs7UUFDL0IsSUFBSSxFQUFFLFNBQVM7O1FBQ2YsS0FBSyxFQUFFLFNBQVM7OztRQUVoQixhQUFhLEVBQUUsS0FBSzs7UUFDcEIscUJBQXFCLEVBQUUsU0FBUyxDQUFDLHFDQUFxQztRQUN0RSwyQ0FBMkM7S0FDNUM7SUFDRCxTQUFTLEVBQUU7UUFDVCxVQUFVLEVBQUUsQ0FBQzs7UUFDYixPQUFPLEVBQUUsS0FBSzs7UUFDZCxPQUFPLEVBQUU7WUFDUCxDQUFDLEVBQUUsSUFBSTtZQUNQLENBQUMsRUFBRSxJQUFJO1lBQ1AsQ0FBQyxFQUFFLElBQUk7WUFDUCxDQUFDLEVBQUUsSUFBSTtZQUNQLEVBQUUsRUFBRSxJQUFJO1lBQ1IsRUFBRSxFQUFFLElBQUk7WUFDUixFQUFFLEVBQUUsSUFBSTtZQUNSLEVBQUUsRUFBRSxJQUFJO1NBQ1Q7O1FBQ0QsSUFBSSxFQUFFLFNBQVM7O1FBQ2YsS0FBSyxFQUFFLFNBQVMsQ0FBQyx5Q0FBeUM7UUFDMUQsdUNBQXVDO0tBQ3hDO0lBQ0QsSUFBSSxFQUFFLElBQUk7O0lBQ1YsaUJBQWlCLEVBQUUsS0FBSzs7SUFDeEIsU0FBUyxFQUFFLEtBQUs7O0lBQ2hCLGlCQUFpQixFQUFFLEtBQUs7O0lBQ3hCLG1CQUFtQixFQUFFLEtBQUs7O0lBQzFCLGNBQWMsRUFBRSxFQUFDLEtBQUssRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUM7O0lBQ2xFLGVBQWUsRUFBRSxLQUFLOztJQUN0QixXQUFXLEVBQUUsV0FBVyxDQUFDLGVBQWU7O0lBQ3hDLG1CQUFtQixFQUFFLEtBQUs7O0lBQzFCLGVBQWUsRUFBRSxLQUFLOztJQUN0QixnQkFBZ0IsRUFBRSxLQUFLOztJQUN2Qix1QkFBdUIsRUFBRSxLQUFLOztJQUM5QixxQkFBcUIsRUFBRSxLQUFLOztJQUM1Qiw2QkFBNkIsRUFBRSxLQUFLOztJQUNwQyxPQUFPLEVBQUUsUUFBUSxDQUFDLEdBQUc7Q0FDdEIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0NvbXBhY3RUeXBlLCBEaXJUeXBlcywgRGlzcGxheUdyaWQsIEdyaWRzdGVyQ29uZmlnLCBHcmlkVHlwZX0gZnJvbSAnLi9ncmlkc3RlckNvbmZpZy5pbnRlcmZhY2UnO1xuXG5leHBvcnQgY29uc3QgR3JpZHN0ZXJDb25maWdTZXJ2aWNlOiBHcmlkc3RlckNvbmZpZyA9IHtcbiAgZ3JpZFR5cGU6IEdyaWRUeXBlLkZpdCwgLy8gJ2ZpdCcgd2lsbCBmaXQgdGhlIGl0ZW1zIGluIHRoZSBjb250YWluZXIgd2l0aG91dCBzY3JvbGw7XG4gIC8vICdzY3JvbGxWZXJ0aWNhbCcgd2lsbCBmaXQgb24gd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgaXRlbXMgd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUgd2lkdGhcbiAgLy8gJ3Njcm9sbEhvcml6b250YWwnIHdpbGwgZml0IG9uIGhlaWdodCBhbmQgd2lkdGggb2YgdGhlIGl0ZW1zIHdpbGwgYmUgdGhlIHNhbWUgYXMgdGhlIGhlaWdodFxuICAvLyAnZml4ZWQnIHdpbGwgc2V0IHRoZSByb3dzIGFuZCBjb2x1bW5zIGRpbWVuc2lvbnMgYmFzZWQgb24gZml4ZWRDb2xXaWR0aCBhbmQgZml4ZWRSb3dIZWlnaHQgb3B0aW9uc1xuICAvLyAndmVydGljYWxGaXhlZCcgd2lsbCBzZXQgdGhlIHJvd3MgdG8gZml4ZWRSb3dIZWlnaHQgYW5kIGNvbHVtbnMgd2lkdGggd2lsbCBmaXQgdGhlIHNwYWNlIGF2YWlsYWJsZVxuICAvLyAnaG9yaXpvbnRhbEZpeGVkJyB3aWxsIHNldCB0aGUgY29sdW1ucyB0byBmaXhlZENvbFdpZHRoIGFuZCByb3dzIGhlaWdodCB3aWxsIGZpdCB0aGUgc3BhY2UgYXZhaWxhYmxlXG4gIGZpeGVkQ29sV2lkdGg6IDI1MCwgLy8gZml4ZWQgY29sIHdpZHRoIGZvciBncmlkVHlwZTogJ2ZpeGVkJ1xuICBmaXhlZFJvd0hlaWdodDogMjUwLCAvLyBmaXhlZCByb3cgaGVpZ2h0IGZvciBncmlkVHlwZTogJ2ZpeGVkJ1xuICBrZWVwRml4ZWRIZWlnaHRJbk1vYmlsZTogZmFsc2UsIC8vIGtlZXAgdGhlIGhlaWdodCBmcm9tIGZpeGVkIGdyaWRUeXBlIGluIG1vYmlsZSBsYXlvdXRcbiAga2VlcEZpeGVkV2lkdGhJbk1vYmlsZTogZmFsc2UsIC8vIGtlZXAgdGhlIHdpZHRoIGZyb20gZml4ZWQgZ3JpZFR5cGUgaW4gbW9iaWxlIGxheW91dFxuICBzZXRHcmlkU2l6ZTogZmFsc2UsIC8vIHNldHMgZ3JpZCBzaXplIGRlcGVuZGluZyBvbiBjb250ZW50XG4gIGNvbXBhY3RUeXBlOiBDb21wYWN0VHlwZS5Ob25lLCAvLyBjb21wYWN0IGl0ZW1zOiAnbm9uZScgfCAnY29tcGFjdFVwJyB8ICdjb21wYWN0TGVmdCcgfCAnY29tcGFjdFVwJkxlZnQnIHwgJ2NvbXBhY3RMZWZ0JlVwJ1xuICBtb2JpbGVCcmVha3BvaW50OiA2NDAsIC8vIGlmIHRoZSBzY3JlZW4gaXMgbm90IHdpZGVyIHRoYXQgdGhpcywgcmVtb3ZlIHRoZSBncmlkIGxheW91dCBhbmQgc3RhY2sgdGhlIGl0ZW1zXG4gIG1pbkNvbHM6IDEsIC8vIG1pbmltdW0gYW1vdW50IG9mIGNvbHVtbnMgaW4gdGhlIGdyaWRcbiAgbWF4Q29sczogMTAwLCAvLyBtYXhpbXVtIGFtb3VudCBvZiBjb2x1bW5zIGluIHRoZSBncmlkXG4gIG1pblJvd3M6IDEsIC8vIG1pbmltdW0gYW1vdW50IG9mIHJvd3MgaW4gdGhlIGdyaWRcbiAgbWF4Um93czogMTAwLCAvLyBtYXhpbXVtIGFtb3VudCBvZiByb3dzIGluIHRoZSBncmlkXG4gIGRlZmF1bHRJdGVtQ29sczogMSwgLy8gZGVmYXVsdCB3aWR0aCBvZiBhbiBpdGVtIGluIGNvbHVtbnNcbiAgZGVmYXVsdEl0ZW1Sb3dzOiAxLCAvLyBkZWZhdWx0IGhlaWdodCBvZiBhbiBpdGVtIGluIHJvd3NcbiAgbWF4SXRlbUNvbHM6IDUwLCAvLyBtYXggaXRlbSBudW1iZXIgb2YgY29sc1xuICBtYXhJdGVtUm93czogNTAsIC8vIG1heCBpdGVtIG51bWJlciBvZiByb3dzXG4gIG1pbkl0ZW1Db2xzOiAxLCAvLyBtaW4gaXRlbSBudW1iZXIgb2YgY29sdW1uc1xuICBtaW5JdGVtUm93czogMSwgLy8gbWluIGl0ZW0gbnVtYmVyIG9mIHJvd3NcbiAgbWluSXRlbUFyZWE6IDEsIC8vIG1pbiBpdGVtIGFyZWE6IGNvbHMgKiByb3dzXG4gIG1heEl0ZW1BcmVhOiAyNTAwLCAvLyBtYXggaXRlbSBhcmVhOiBjb2xzICogcm93c1xuICBtYXJnaW46IDEwLCAgLy8gbWFyZ2luIGJldHdlZW4gZ3JpZCBpdGVtc1xuICBvdXRlck1hcmdpbjogdHJ1ZSwgIC8vIGlmIG1hcmdpbnMgd2lsbCBhcHBseSB0byB0aGUgc2lkZXMgb2YgdGhlIGNvbnRhaW5lclxuICBvdXRlck1hcmdpblRvcDogbnVsbCwgLy8gb3ZlcnJpZGUgb3V0ZXIgbWFyZ2luIGZvciBncmlkXG4gIG91dGVyTWFyZ2luUmlnaHQ6IG51bGwsIC8vIG92ZXJyaWRlIG91dGVyIG1hcmdpbiBmb3IgZ3JpZFxuICBvdXRlck1hcmdpbkJvdHRvbTogbnVsbCwgLy8gb3ZlcnJpZGUgb3V0ZXIgbWFyZ2luIGZvciBncmlkXG4gIG91dGVyTWFyZ2luTGVmdDogbnVsbCwgLy8gb3ZlcnJpZGUgb3V0ZXIgbWFyZ2luIGZvciBncmlkXG4gIHVzZVRyYW5zZm9ybVBvc2l0aW9uaW5nOiB0cnVlLCAvLyB0b2dnbGUgYmV0d2VlbiB0cmFuc2Zvcm0gb3IgdG9wL2xlZnQgcG9zaXRpb25pbmcgb2YgaXRlbXNcbiAgc2Nyb2xsU2Vuc2l0aXZpdHk6IDEwLCAgLy8gbWFyZ2luIG9mIHRoZSBkYXNoYm9hcmQgd2hlcmUgdG8gc3RhcnQgc2Nyb2xsaW5nXG4gIHNjcm9sbFNwZWVkOiAyMCwgIC8vIGhvdyBtdWNoIHRvIHNjcm9sbCBlYWNoIG1vdXNlIG1vdmUgd2hlbiBpbiB0aGUgc2Nyb2xsU2Vuc2l0aXZpdHkgem9uZVxuICBpbml0Q2FsbGJhY2s6IHVuZGVmaW5lZCwgLy8gY2FsbGJhY2sgdG8gY2FsbCBhZnRlciBncmlkIGhhcyBpbml0aWFsaXplZC4gQXJndW1lbnRzOiBncmlkc3RlckNvbXBvbmVudFxuICBkZXN0cm95Q2FsbGJhY2s6IHVuZGVmaW5lZCwgLy8gY2FsbGJhY2sgdG8gY2FsbCBhZnRlciBncmlkIGhhcyBkZXN0cm95ZWQuIEFyZ3VtZW50czogZ3JpZHN0ZXJDb21wb25lbnRcbiAgZ3JpZFNpemVDaGFuZ2VkQ2FsbGJhY2s6IHVuZGVmaW5lZCwgLy8gY2FsbGJhY2sgdG8gY2FsbCBhZnRlciBncmlkIGhhcyBjaGFuZ2VkIHNpemUuIEFyZ3VtZW50czogZ3JpZHN0ZXJDb21wb25lbnRcbiAgaXRlbUNoYW5nZUNhbGxiYWNrOiB1bmRlZmluZWQsICAvLyBjYWxsYmFjayB0byBjYWxsIGZvciBlYWNoIGl0ZW0gd2hlbiBpcyBjaGFuZ2VzIHgsIHksIHJvd3MsIGNvbHMuXG4gIC8vIEFyZ3VtZW50czogZ3JpZHN0ZXJJdGVtLCBncmlkc3Rlckl0ZW1Db21wb25lbnRcbiAgaXRlbVJlc2l6ZUNhbGxiYWNrOiB1bmRlZmluZWQsICAvLyBjYWxsYmFjayB0byBjYWxsIGZvciBlYWNoIGl0ZW0gd2hlbiB3aWR0aC9oZWlnaHQgY2hhbmdlcy5cbiAgLy8gQXJndW1lbnRzOiBncmlkc3Rlckl0ZW0sIGdyaWRzdGVySXRlbUNvbXBvbmVudFxuICBpdGVtSW5pdENhbGxiYWNrOiB1bmRlZmluZWQsICAvLyBjYWxsYmFjayB0byBjYWxsIGZvciBlYWNoIGl0ZW0gd2hlbiBpcyBpbml0aWFsaXplZC5cbiAgLy8gQXJndW1lbnRzOiBncmlkc3Rlckl0ZW0sIGdyaWRzdGVySXRlbUNvbXBvbmVudFxuICBpdGVtUmVtb3ZlZENhbGxiYWNrOiB1bmRlZmluZWQsICAvLyBjYWxsYmFjayB0byBjYWxsIGZvciBlYWNoIGl0ZW0gd2hlbiBpcyBpbml0aWFsaXplZC5cbiAgLy8gQXJndW1lbnRzOiBncmlkc3Rlckl0ZW0sIGdyaWRzdGVySXRlbUNvbXBvbmVudFxuICBpdGVtVmFsaWRhdGVDYWxsYmFjazogdW5kZWZpbmVkLCAgLy8gY2FsbGJhY2sgdG8gY2FsbCB0byB2YWxpZGF0ZSBpdGVtIHBvc2l0aW9uL3NpemUuIFJldHVybiB0cnVlIGlmIHZhbGlkLlxuICAvLyBBcmd1bWVudHM6IGdyaWRzdGVySXRlbVxuICBlbmFibGVFbXB0eUNlbGxDbGljazogZmFsc2UsIC8vIGVuYWJsZSBlbXB0eSBjZWxsIGNsaWNrIGV2ZW50c1xuICBlbmFibGVFbXB0eUNlbGxDb250ZXh0TWVudTogZmFsc2UsIC8vIGVuYWJsZSBlbXB0eSBjZWxsIGNvbnRleHQgbWVudSAocmlnaHQgY2xpY2spIGV2ZW50c1xuICBlbmFibGVFbXB0eUNlbGxEcm9wOiBmYWxzZSwgLy8gZW5hYmxlIGVtcHR5IGNlbGwgZHJvcCBldmVudHNcbiAgZW5hYmxlRW1wdHlDZWxsRHJhZzogZmFsc2UsIC8vIGVuYWJsZSBlbXB0eSBjZWxsIGRyYWcgZXZlbnRzXG4gIGVuYWJsZU9jY3VwaWVkQ2VsbERyb3A6IGZhbHNlLCAvLyBlbmFibGUgb2NjdXBpZWQgY2VsbCBkcm9wIGV2ZW50c1xuICBlbXB0eUNlbGxDbGlja0NhbGxiYWNrOiB1bmRlZmluZWQsIC8vIGVtcHR5IGNlbGwgY2xpY2sgY2FsbGJhY2tcbiAgZW1wdHlDZWxsQ29udGV4dE1lbnVDYWxsYmFjazogdW5kZWZpbmVkLCAvLyBlbXB0eSBjZWxsIGNvbnRleHQgbWVudSAocmlnaHQgY2xpY2spIGNhbGxiYWNrXG4gIGVtcHR5Q2VsbERyb3BDYWxsYmFjazogdW5kZWZpbmVkLCAvLyBlbXB0eSBjZWxsIGRyYWcgZHJvcCBjYWxsYmFjay4gSFRNTDUgRHJhZyAmIERyb3BcbiAgZW1wdHlDZWxsRHJhZ0NhbGxiYWNrOiB1bmRlZmluZWQsIC8vIGVtcHR5IGNlbGwgZHJhZyBhbmQgY3JlYXRlIGl0ZW0gbGlrZSBleGNlbCBjZWxsIHNlbGVjdGlvblxuICBlbXB0eUNlbGxEcmFnTWF4Q29sczogNTAsIC8vIGxpbWl0IGVtcHR5IGNlbGwgZHJhZyBtYXggY29sc1xuICBlbXB0eUNlbGxEcmFnTWF4Um93czogNTAsIC8vIGxpbWl0IGVtcHR5IGNlbGwgZHJhZyBtYXggcm93c1xuICBzY2FsZTogMSwgLy8gc2NhbGUgcGFyYW0gdG8gem9vbSBpbi96b29tIG91dFxuICAvLyBBcmd1bWVudHM6IGV2ZW50LCBncmlkc3Rlckl0ZW17eCwgeSwgcm93czogZGVmYXVsdEl0ZW1Sb3dzLCBjb2xzOiBkZWZhdWx0SXRlbUNvbHN9XG4gIGlnbm9yZU1hcmdpbkluUm93OiBmYWxzZSwgLy8gaWdub3JlIHRoZSBnYXAgYmV0d2VlbiByb3dzIGZvciBpdGVtcyB3aGljaCBzcGFuIG11bHRpcGxlIHJvd3MgKHNlZSAjMTYyLCAjMjI0KVxuICBkcmFnZ2FibGU6IHtcbiAgICBkZWxheVN0YXJ0OiAwLCAvLyBtaWxsaXNlY29uZHMgdG8gZGVsYXkgdGhlIHN0YXJ0IG9mIGRyYWcsIHVzZWZ1bCBmb3IgdG91Y2ggaW50ZXJhY3Rpb25cbiAgICBlbmFibGVkOiBmYWxzZSwgLy8gZW5hYmxlL2Rpc2FibGUgZHJhZ2dhYmxlIGl0ZW1zXG4gICAgaWdub3JlQ29udGVudENsYXNzOiAnZ3JpZHN0ZXItaXRlbS1jb250ZW50JywgLy8gZGVmYXVsdCBjb250ZW50IGNsYXNzIHRvIGlnbm9yZSB0aGUgZHJhZyBldmVudCBmcm9tXG4gICAgaWdub3JlQ29udGVudDogZmFsc2UsIC8vIGlmIHRydWUgZHJhZyB3aWxsIHN0YXJ0IG9ubHkgZnJvbSBlbGVtZW50cyBmcm9tIGBkcmFnSGFuZGxlQ2xhc3NgXG4gICAgZHJhZ0hhbmRsZUNsYXNzOiAnZHJhZy1oYW5kbGVyJywgLy8gZHJhZyBldmVudCBvbmx5IGZyb20gdGhpcyBjbGFzcy4gSWYgYGlnbm9yZUNvbnRlbnRgIGlzIHRydWUuXG4gICAgc3RvcDogdW5kZWZpbmVkLCAvLyBjYWxsYmFjayB3aGVuIGRyYWdnaW5nIGFuIGl0ZW0gc3RvcHMuICBBY2NlcHRzIFByb21pc2UgcmV0dXJuIHRvIGNhbmNlbC9hcHByb3ZlIGRyYWcuXG4gICAgc3RhcnQ6IHVuZGVmaW5lZCwgLy8gY2FsbGJhY2sgd2hlbiBkcmFnZ2luZyBhbiBpdGVtIHN0YXJ0cy5cbiAgICAvLyBBcmd1bWVudHM6IGl0ZW0sIGdyaWRzdGVySXRlbSwgZXZlbnRcbiAgICBkcm9wT3Zlckl0ZW1zOiBmYWxzZSwgLy8gZW5hYmxlIGRyb3AgaXRlbXMgb24gdG9wIG90aGVyIGl0ZW1cbiAgICBkcm9wT3Zlckl0ZW1zQ2FsbGJhY2s6IHVuZGVmaW5lZCAvLyBjYWxsYmFjayBvbiBkcm9wIG92ZXIgYW5vdGhlciBpdGVtXG4gICAgLy8gQXJndW1lbnRzOiBzb3VyY2UsIHRhcmdldCwgZ3JpZENvbXBvbmVudFxuICB9LFxuICByZXNpemFibGU6IHtcbiAgICBkZWxheVN0YXJ0OiAwLCAvLyBtaWxsaXNlY29uZHMgdG8gZGVsYXkgdGhlIHN0YXJ0IG9mIHJlc2l6ZSwgdXNlZnVsIGZvciB0b3VjaCBpbnRlcmFjdGlvblxuICAgIGVuYWJsZWQ6IGZhbHNlLCAvLyBlbmFibGUvZGlzYWJsZSByZXNpemFibGUgaXRlbXNcbiAgICBoYW5kbGVzOiB7XG4gICAgICBzOiB0cnVlLFxuICAgICAgZTogdHJ1ZSxcbiAgICAgIG46IHRydWUsXG4gICAgICB3OiB0cnVlLFxuICAgICAgc2U6IHRydWUsXG4gICAgICBuZTogdHJ1ZSxcbiAgICAgIHN3OiB0cnVlLFxuICAgICAgbnc6IHRydWVcbiAgICB9LCAvLyByZXNpemFibGUgZWRnZXMgb2YgYW4gaXRlbVxuICAgIHN0b3A6IHVuZGVmaW5lZCwgLy8gY2FsbGJhY2sgd2hlbiByZXNpemluZyBhbiBpdGVtIHN0b3BzLiBBY2NlcHRzIFByb21pc2UgcmV0dXJuIHRvIGNhbmNlbC9hcHByb3ZlIHJlc2l6ZS5cbiAgICBzdGFydDogdW5kZWZpbmVkIC8vIGNhbGxiYWNrIHdoZW4gcmVzaXppbmcgYW4gaXRlbSBzdGFydHMuXG4gICAgLy8gQXJndW1lbnRzOiBpdGVtLCBncmlkc3Rlckl0ZW0sIGV2ZW50XG4gIH0sXG4gIHN3YXA6IHRydWUsIC8vIGFsbG93IGl0ZW1zIHRvIHN3aXRjaCBwb3NpdGlvbiBpZiBkcm9wIG9uIHRvcCBvZiBhbm90aGVyXG4gIHN3YXBXaGlsZURyYWdnaW5nOiBmYWxzZSwgLy8gYWxsb3cgaXRlbXMgdG8gc3dpdGNoIHBvc2l0aW9uIHdoaWxlIGRyYWdnaW5nXG4gIHB1c2hJdGVtczogZmFsc2UsIC8vIHB1c2ggaXRlbXMgd2hlbiByZXNpemluZyBhbmQgZHJhZ2dpbmdcbiAgZGlzYWJsZVB1c2hPbkRyYWc6IGZhbHNlLCAvLyBkaXNhYmxlIHB1c2ggb24gZHJhZ1xuICBkaXNhYmxlUHVzaE9uUmVzaXplOiBmYWxzZSwgLy8gZGlzYWJsZSBwdXNoIG9uIHJlc2l6ZVxuICBwdXNoRGlyZWN0aW9uczoge25vcnRoOiB0cnVlLCBlYXN0OiB0cnVlLCBzb3V0aDogdHJ1ZSwgd2VzdDogdHJ1ZX0sIC8vIGNvbnRyb2wgdGhlIGRpcmVjdGlvbnMgaXRlbXMgYXJlIHB1c2hlZFxuICBwdXNoUmVzaXplSXRlbXM6IGZhbHNlLCAvLyBvbiByZXNpemUgb2YgaXRlbSB3aWxsIHNocmluayBhZGphY2VudCBpdGVtc1xuICBkaXNwbGF5R3JpZDogRGlzcGxheUdyaWQuT25EcmFnQW5kUmVzaXplLCAvLyBkaXNwbGF5IGJhY2tncm91bmQgZ3JpZCBvZiByb3dzIGFuZCBjb2x1bW5zXG4gIGRpc2FibGVXaW5kb3dSZXNpemU6IGZhbHNlLCAvLyBkaXNhYmxlIHRoZSB3aW5kb3cgb24gcmVzaXplIGxpc3RlbmVyLiBUaGlzIHdpbGwgc3RvcCBncmlkIHRvIHJlY2FsY3VsYXRlIG9uIHdpbmRvdyByZXNpemUuXG4gIGRpc2FibGVXYXJuaW5nczogZmFsc2UsIC8vIGRpc2FibGUgY29uc29sZSBsb2cgd2FybmluZ3MgYWJvdXQgbWlzcGxhY2VtZW50IG9mIGdyaWQgaXRlbXNcbiAgc2Nyb2xsVG9OZXdJdGVtczogZmFsc2UsIC8vIHNjcm9sbCB0byBuZXcgaXRlbXMgcGxhY2VkIGluIGEgc2Nyb2xsYWJsZSB2aWV3XG4gIGRpc2FibGVTY3JvbGxIb3Jpem9udGFsOiBmYWxzZSwgLy8gZGlzYWJsZSBob3Jpem9udGFsIHNjcm9sbGluZ1xuICBkaXNhYmxlU2Nyb2xsVmVydGljYWw6IGZhbHNlLCAvLyBkaXNhYmxlIHZlcnRpY2FsIHNjcm9sbGluZ1xuICBkaXNhYmxlQXV0b1Bvc2l0aW9uT25Db25mbGljdDogZmFsc2UsICAvLyBkaXNhYmxlIGF1dG8tcG9zaXRpb24gb2YgaXRlbXMgb24gY29uZmxpY3Qgc3RhdGUsXG4gIGRpclR5cGU6IERpclR5cGVzLkxUUiwgLy8gcGFnZSBkaXJlY3Rpb24sIHJ0bD1yaWdodCB0byBsZWZ0IGx0cj0gbGVmdCB0byByaWdodCwgaWYgeW91IHVzZSBydGwgbGFuZ3VhZ2Ugc2V0IGRpclR5cGUgdG8gcnRsXG59O1xuIl19