import { ChangeDetectorRef, ElementRef, NgZone, OnChanges, OnDestroy, OnInit, Renderer2, SimpleChanges } from '@angular/core';
import { GridsterComponentInterface } from './gridster.interface';
import { GridsterCompact } from './gridsterCompact.service';
import { GridsterConfig } from './gridsterConfig.interface';
import { GridsterConfigS } from './gridsterConfigS.interface';
import { GridsterEmptyCell } from './gridsterEmptyCell.service';
import { GridsterItem } from './gridsterItem.interface';
import { GridsterItemComponentInterface } from './gridsterItemComponent.interface';
import { GridsterRenderer } from './gridsterRenderer.service';
export declare class GridsterComponent implements OnInit, OnChanges, OnDestroy, GridsterComponentInterface {
    renderer: Renderer2;
    cdRef: ChangeDetectorRef;
    zone: NgZone;
    options: GridsterConfig;
    calculateLayoutDebounce: () => void;
    movingItem: GridsterItem | null;
    previewStyle: () => void;
    el: any;
    $options: GridsterConfigS;
    mobile: boolean;
    curWidth: number;
    curHeight: number;
    grid: Array<GridsterItemComponentInterface>;
    columns: number;
    rows: number;
    curColWidth: number;
    curRowHeight: number;
    gridColumns: never[];
    gridRows: never[];
    windowResize: (() => void) | null;
    dragInProgress: boolean;
    emptyCell: GridsterEmptyCell;
    compact: GridsterCompact;
    gridRenderer: GridsterRenderer;
    constructor(el: ElementRef, renderer: Renderer2, cdRef: ChangeDetectorRef, zone: NgZone);
    static checkCollisionTwoItems(item: GridsterItem, item2: GridsterItem): boolean;
    ngOnInit(): void;
    ngOnChanges(changes: SimpleChanges): void;
    resize(): void;
    setOptions(): void;
    optionsChanged(): void;
    ngOnDestroy(): void;
    onResize(): void;
    checkIfToResize(): boolean;
    setGridSize(): void;
    setGridDimensions(): void;
    calculateLayout(): void;
    updateGrid(): void;
    addItem(itemComponent: GridsterItemComponentInterface): void;
    removeItem(itemComponent: GridsterItemComponentInterface): void;
    checkCollision(item: GridsterItem): GridsterItemComponentInterface | boolean;
    checkGridCollision(item: GridsterItem): boolean;
    findItemWithItem(item: GridsterItem): GridsterItemComponentInterface | boolean;
    findItemsWithItem(item: GridsterItem): Array<GridsterItemComponentInterface>;
    autoPositionItem(itemComponent: GridsterItemComponentInterface): void;
    getNextPossiblePosition(newItem: GridsterItem, startingFrom?: {
        y?: number;
        x?: number;
    }): boolean;
    getFirstPossiblePosition(item: GridsterItem): GridsterItem;
    getLastPossiblePosition(item: GridsterItem): GridsterItem;
    pixelsToPositionX(x: number, roundingMethod: (x: number) => number, noLimit?: boolean): number;
    pixelsToPositionY(y: number, roundingMethod: (x: number) => number, noLimit?: boolean): number;
    positionXToPixels(x: number): number;
    positionYToPixels(y: number): number;
    static checkCollisionTwoItemsForSwaping(item: GridsterItem, item2: GridsterItem): boolean;
    checkCollisionForSwaping(item: GridsterItem): GridsterItemComponentInterface | boolean;
    findItemWithItemForSwaping(item: GridsterItem): GridsterItemComponentInterface | boolean;
    private static getNewArrayLength;
}
